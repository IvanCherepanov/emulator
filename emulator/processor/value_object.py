from enum import Enum

# Определение команд и типов адресации
class Opcode(Enum):
    """"""
    LDA = 1  # Загрузка данных в аккумулятор с переданного типа адресации по конкретному адресу
    ADD = 2  # Сложение
    STA = 4  # Сохранение данных аккумулятора в память по переданному типу адресации
    JMP = 5  # Безусловный переход
    JZ = 6   # Условный переход
    CMP = 7  # Сравнение
    HLT = 15 # Выход


class AddressingMode(Enum):
    """Типы адресации"""
    DIRECT = 0           # Прямая адресация (?); LDA ?30 - Загрузить в аккумулятор слово из ячейки с адресом 30
    IMMEDIATE = 1        # Непосредственная адресация (#); LDA #30 - загрузить в аккумулятор слово "30", в команде содержится сам операнд, загрузка его из памяти не требуется
    REGISTER = 2         # Регистровая адресация (/); LDA /A - Загрузить в аккумулятор слово из регистра A
    INDIRECT_REGISTER = 3 # Косвенно-регистровая адресация (@); LDA @30 - загрузить в аккумулятор слово из ячейки, адрес которой находится в ячейке 30, в команде содержится адрес адреса операнд


class GeneralProposeRegisters(Enum):
    A = 1
    B = 2
    C = 3

    @classmethod
    def has_member(cls, name):
        """Проверяет наличие элемента в перечислении по имени."""
        return name in cls.__members__

    @classmethod
    def get_name_by_value(cls, value):
        """Возвращает имя элемента по значению, если он существует."""
        for member in cls:
            if member.value == value:
                return member.name
        return None  # Возвращаем None, если элемент не найден
